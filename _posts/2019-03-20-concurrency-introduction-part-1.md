---
layout: post
title:  "Introduction to Concurrency(Part 1)"
date:   2019-03-20 09:00:00
categories: LINK(OICW)
permalink: /archivers/concurrency_introduction_part_1
---

# C++ Multithreading (Part 1)
## 표준 쓰레드 지원 라이브러리 맛보기

> 필자는 공군 작전정보통신단 체계개발실에서 복무('17~'19)하였습니다. 이 포스트는 작전정보통신단 병사 **프로그래밍 동아리(LINK)** 에서의 활동을 바탕으로 작성한 내용입니다.

## Hello Thread!! - 배경 이야기

처음 전입 왔을 당시인 17년에 제가 받았던 프로젝트가 하나 있었습니다. MFC 프로젝트였죠. 팀 내부에서 자체적으로 만든 프로그램으로, **외부 업체**에서 제작한 프로그램을 베이스로 한, 일부를 변형시켜 작성한 프로젝트(RTD: 가명)였습니다. 

간단하게 이야기하자면, 그 동안은 사용자가 정보를 직접 수기로 입력하는 것이었습니다. 예를 들어 한 모니터에 어떠한 정보가 표시되면 그것을 불러주는 사람이 따로 있고 다른 곳(컴퓨터)에 작성하는 사람 따로 있는, 그런 비효율적인 과정이었습니다. 어차피 그 정보들도 어느 곳에서 가져오는 것이니 그 로그를 읽어 자동으로 가져오면 되는 것 아니냐 해서 만들어 진 것이 그 RTD 프로젝트입니다. 조금 안타까운 것이라면 자동화라고는 해도 모든 로그를 긁어와 사람이 선택적으로 체크하고 해제해야 하는 작업도 필요해서 그렇게 많이 쓰이지는 않았던 체계입니다.

지금이야 예전에 비해 각종 의욕을 잃어버린 지 오래이지만 당시에만 해도 무슨 일이든 던져만 주면 해보이겠다는 의지가 충만했습니다. 학교에서 간단하게나마 MFC를 하긴 했지만 거의 보지도 않은 수준이었는데 소스는 받았으니 분석은 해야겠고, 해서 빠른 속도로 MFC 구조를 익히고 소스를 분석하기 시작했습니다. 무슨 생각이었는지 한쇼로 프로그램 작동 구조를 일일이 그리고 도표로 클래스와 메서드를 정리하기 시작했습니다. 새로 프로그램을 작성하는 일 보다 남이 작성한 소스를 쳐다보는 것이 더 고된 일이라는 걸 그때 확실히 피부로 느낀 것 같습니다. 

뒤져보니 아직도 관련 자료가 남아있네요. 어떻게 일일이 그렸는지 다시 하라면 못 할 짓입니다. 한쇼 파일 여는 데에만 해도 5~6초가 걸립니다.

각설하고, RTD 프로젝트는 약간의 문제가 있었습니다. 로그에서 찍히는 정보가 어마무시하다 보니 이놈이 정보를 가져오고 처리하는데 시간을 좀 잡아먹습니다. 시뮬레이터 장비로 정보를 쏘게 되면 가져오고 전시하는 데에만 몇 십초. 어떤 로직으로 짜여져 있는지 그 도중에는 마우스나 각종 입력이 먹히지 않습니다. 

그래서 저에게 던져진 것이 데이터 처리와 사용자 입력 로직을 분리해라. 즉, 데이터 처리 과정을 별도의 쓰레드(Thread)로 만들어 사용자 입력 처리가 가능하게 하라는 것이었죠. 하나의 쓰레드는 작업(worker thread)을, 다른 하나의 쓰레드는 사용자 입력을 받도록 하도록 만드는 작업이었습니다. 

*예전에 올려 둔 자료에 MFC Thread Control에 대한 내용이 있습니다.*

뭐, 어찌어찌해서 결국 별도의 쓰레드로 돌아가게 만들기는 했습니다. 그런데 소스를 갖다 주기도 전에 개발실장이 바뀌면서 프로젝트가 터졌습니다. 하지 말랍니다. 잠정 중단이죠. 이건 뭐 돌려보지도 못하고 갖다 버린 꼴이 되어버린 비운의 프로젝트입니다. 

Sad 엔딩이지만 이게 제가 처음 멀티쓰레드라는 놈을 만난 계기입니다.


## C++11, 쓰레드 지원 라이브러리

아무리 많은 복잡한 함수를 작성하고 복잡한 클래스를 작성하고, 복잡한 Recursive 동작을 구현해도 대부분 main()안에 구겨 넣는 식의 하나의 쓰레드(Window는 쓰레드 개념 기반)만 만들면 되었습니다. 그러나 MFC 또는 기타 언어(Java runnable 등)으로 멀티쓰레드 기반 프로그램을 작성해 본 경험이 있는 사람들은 아마 느끼시겠지만 멀티쓰레드 프로그램은 고려해야 할 대상이 아주 많습니다. 하나의 쓰레드가 돌아감과 동시에 다른 로직이 작동중이니 다수의 동작을 동시에 고려해야 하는 상황이고, 우리가 작성한 코드는 이제는 단순히 위에서 아래로가 아니라 여기저기에서 동시 다발적으로 작동하기 때문입니다. 

RTD 프로젝트는 Visual Studio 2008에서 작성된 프로젝트입니다. 물론 MFC니 윈도우에서 지원해주는 각종 쓰레드 라이브러리를 이용하는게 훨씬 더 효율적이었겠지만 만일 유닉스/리눅스에서 동일하게 작동하는 로직을 필요로 하는 소요가 들어왔다면 아마 pthread 라이브러리를 이용하여 다시 한 번 더 갈아엎었어야 했을 겁니다. 2008이면 C++11을 지원하지 않기 때문이죠.

C++11은 언어적으로도 그렇지만 표준 라이브러리 측면에서도 추가된 사항이 굉장히 많습니다. “이전의 C++과 C++11이후는 완전히 새로운 언어라고 느껴진다.”라는 표현이 딱 들어 맞는 것 같습니다. C++11에 드디어 쓰레드 지원 라이브러리가 추가되었습니다. 

![reference](/assets/posts/2019-03-20-concurrency-introduction-part-1/2019-03-20-00.jpg)

C++ 표준의 쓰레드 지원은 크게 두 부분으로 구성되는데, 하나는 잘 정의된(well-defined) 메모리 모형이고 또 하나는 표준화된 쓰레드 적용 인터페이스입니다.

다중 쓰레드 적용의 기초는 잘 정의된 메모리 모형입니다. 메모리 모형(Memory model)은 반드시 다음과 같은 사항을 지원해야됩니다. 

- 원자적(atomic) 연산: 가로채기(interrupt)없이 수행할 수 있는 연산.
- 연산들의 부분 순서(partial ordering): 일련의 연산들의 순서를 바꾸지 않아야 한다.
- 연산의 가시적 효과: 공유 변수에 대한 연산의 결과를 다른 쓰레드에서도 볼 수 있음을 보장해야 한다.

C++ 메모리 모형에 대한 내용은 따로 공부 중이니 Part 1에서는 쓰레드 적용 인터페이스부터 알아보는 거로 하죠. 

## 환경

들어가기 전에 컴파일 환경은 Ubuntu 16.04 LTS([구름IDE](https://ide.goorm.io)), gcc/g++ 8.1로 두겠습니다. C++11은 gnu 컴파일러 4.7 이상이면 됩니다. 기본적으로 구름IDE에서 빈 프로젝트로 컨테이너 생성 시 gcc/g++ 4.8.4 버전이 깔려 있습니다. 

![bash](/assets/posts/2019-03-20-concurrency-introduction-part-1/2019-03-20-01.jpg)

쓰레드 라이브러리를 컴파일하기에 충분할 것이라 생각은 됩니다만 추후 C++17 라이브러리를 쓸 수도 있으니 그냥 최신 버전으로 업데이트를 미리 해 두겠습니다. 몇 번 삽질 한 결과 아래와 같이 진행하면 됩니다. 

```bash
sudo add-apt-repository ppa:ubuntu-toolchain-r/test
sudo apt-get update
```

![bash](/assets/posts/2019-03-20-concurrency-introduction-part-1/2019-03-20-02.jpg)

![bash](/assets/posts/2019-03-20-concurrency-introduction-part-1/2019-03-20-03.jpg)

```bash
sudo apt-get install gcc-8 g++-8
```

![bash](/assets/posts/2019-03-20-concurrency-introduction-part-1/2019-03-20-04.jpg)

![bash](/assets/posts/2019-03-20-concurrency-introduction-part-1/2019-03-20-05.jpg)

아직도 4.8.4 버전이군요. 업그레이드 버전으로 잡아 줍니다.

```bash
sudo update-alternatives --install /usr/bin/gcc /usr/bin/gcc-8 800 --slave /usr/bin/g++ /usr/bin/g++-8
```
![bash](/assets/posts/2019-03-20-concurrency-introduction-part-1/2019-03-20-06.jpg)

확인하고 gdb도 깔아 줍시다. 빈 컨테이너에는 gdb가 없더라고요.

```bash
sudo apt-get install gdb
```

![bash](/assets/posts/2019-03-20-concurrency-introduction-part-1/2019-03-20-07.jpg)

그러면 환경 설정은 완료됩니다.

![bash](/assets/posts/2019-03-20-concurrency-introduction-part-1/2019-03-20-08.jpg)

인터넷이 되는 환경이라 자료 찾아보기도 편하고 너무 좋군요. 

추후 예제에 쓸 함수를 하나 만들어 둡시다. 리눅스에서는 윈도우 VS에서 지원하는 getch() 함수가 존재하지 않습니다. 따라서 아래와 같이 하나 만들어 둡니다. 

```cpp
#include <stdio.h>
#include <termio.h>

int getch(void) {

	int ch;
	struct termios buf, save;
	
	tcgetattr(0, &save);
	
	buf = save;
	
	buf.c_flag &= ~(ICANON | ECHO);
	buf.c_cc[VMIN] = 1;
	buf.c_cc[VTIME] = 0;
	
	tcsetattr(0, TCSAFLUSH, &buf);
	
	ch = getchar();
	tcsetattr(0, TCSAFLUSH, &save);
	
	return ch;

}
```


